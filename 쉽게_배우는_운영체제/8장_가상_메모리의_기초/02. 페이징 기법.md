# 02. 페이징 기법

### 1. 페이징 기법의 구현

- 정의
  - 고정 분할 방식을 이용한 가상 메모리 관리 기법
  - 물리 주소 공간을 같은 크기로 나누어 사용한다.
- 프레임
  - 가상 메모리의 주소는 페이지, 물리 메모리의 주소는 프레임이라고 부르며, 가상 메모리와 구분한다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/97b0a30a-7067-4d35-bb63-7f2fabc35aa6/ebadde2e-39fa-4b5f-8dd2-6523fac2bff7/Untitled.png)

### 2. 페이징 기법의 주소 변환

`주소 변환 과정`

가상 주소를 물리 주소를 변환하는 과정에서 프로세스가 30번의 내용을 읽으려고 할 때의 주소 변환 과정은 다음과 같다.

1. 가상 주소 30번이 어느 페이지에 있는지 차즌ㄴ다. 30번은 페이지 3의 0번 위치에 있다.
2. 페이지 테이블의 페이지 3으로 가서 해당 페이지가 프레임 1에 있다는 것을 알아낸다.
3. 최종적으로 물리 메모리 프레임 1의 0번 위치에 접근한다. 이 주소가 가상 주소 30번의 물리 주소다.

프로세스가 가상 주소 18번에 어떤 값을 저장하려고 할 때의 주소 변환 과정을 살펴보자.

1. 가장 주소 18번이 어느 페이지에 있는지 찾는다. 18번은 페이지 1의 8번 위치에 있다.
2. 페이지 테이블의 페이지 1로 가서 해당 페이지가 프레임 3에 있다는 것을 알아낸다.
3. 프로세스가 저장하려는 값을 프레임 3의 8번에 저장 한다.

`정형화된 주소 변환`

- 페이징 기법에서의 가상 주소 표현 방식

```jsx
VA = <P, D>

VA는 가상 주소, P는 페이지, D는 페이지의 처음 위치에서 해당 주소까지의 거리를 의미한다.
```

- 물리 주소 표현 방식

```jsx
PA=<F,D>
PA는 물리 메모리 주소, F는 프레임, D는 처음 위치에서 해당 주소까지의 거리를 의미한다.
```

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/97b0a30a-7067-4d35-bb63-7f2fabc35aa6/d17cfcd6-d591-4779-8322-7bc2fecb0125/Untitled.png)

페이지 테이블을 이용하면 간단하게 가상 주소를 물리주소로 변환할 수 있다.

`페이지 테이블 엔트리`

- 페이지 번호와 프레임 번호로 구성되어, 프레임 번호로 구성된 페이지 테이블 엔트리의 집합이다.

### 3. 페이지 테이블 관리

`메모리 공유`

- 개요
  - 시스템에 여러 프로세스가 있고, 프로세스마다 페이지 테이블이 하나씩 있기 때문에, 페이지 테이블 관리가 복잡하다.
  - 페이지 테이블은 메모리 관리자가 자주 사용하는 자료구조이기 때문에, 운영체제 영역의 일부분에 모아 놓는다.
- 페이지 테이블 관리의 문제점
  - 32bit CPU에 한 페이지가 512B인 페이징 시스템이 있다고 가정해 볼 때, 4GB의 물리메모리를 512B로 페이지를 나누면, 페이지 테이블의 크기가 24MB다.
  - 이를 프로세스마다 갖게 해야 하기 때문에, 너무 많은 메모리를 페이지 테이블에 할당해야 한다.

→ 따라서, 페이지 테이블의 크기를 적절하게 유지하는 것이 페이지 테이블 관리의 핵심

`페이지 테이블 기준 레지스터(PTBR: Page Table Base Register)`

- 개요
  - 메모리 관리자는 프로세스가 메모리에 접근하기 위한 페이지 테이블의 주소에 빠르게 접근해야하기 위해, 각 페이지 테이블의 시작 주소를 페이지 테이블 기준 레지스터에 보관한다.

`쓰기 시점 복사`

동시에 여러 개의 같은 크롬 브라우저를 메모리에 올려 놓으면 메모리가 낭비될 것이고, 낭비를 줄이는 방법은 메모리에 크롬 브라우저를 하나만 올려놓고 공유하는 것이다.

- 공유할 수 있는 영역
  - 기본적인 소스 코드
- 공유할 수 없는 영역
  - 데이터, 동적 할당 영역등
  - 각 탭에서 서로 다른 페이지를 보고 있을 것이기 때문에, 이는 공유할 수 없어서, 해당 메모리 영역은 프로세스별로 각각 다른 페이지 테이블을 가리킨다.
- 공유할 수 없는 데이터의 메모리 공간 확보
  - 미리 데이터 영역을 확보하면, 메모리 공간의 낭비로 이어진다. 같은 구글탭을 가리키고 있는 각자의 크롬 탭은 다른 탭이 네이버로 이동하는 순간 새로운 프레임이 복사되어 바뀐다.
  - 이처럼, 데이터 변화가 있을 때까지 복사를 미루는 방식을 쓰기 시점 복사라고 한다.

`변환 색인 버퍼`

가상 주소를 물리 주소로 변환하는 작업은 CPU의 MMU(메모리 관리 유닛)이 담당한다.

1. 메모리 관리 유닛이 가상 주소를 받아 물리 주소를 변환하려면 페이지 테이블이 필요하다.
2. 페이지 테이블은 메모리에 있어, MMU는 메모리에 있는 페이지 테이블에 접근하여 물리 주소로 변환한다.
3. 변환된 물리 주소를 이용하여 필요한 데이터를 가져온다.

→ 일일이 메모리에 접근하면, 성능이 떨어지기 때문에, 페이지 테이블의 일부를 CPU에 가져온다. 이를 변환 색인 버퍼라고 한다.

- 지역성 이론에 근거하는 변환 색인 버퍼
  - 캐시된 페이지 테이블을 변환 색인 버퍼라고 부르는데, 현재 사용 중이거나, 사용이 예상되는 페이지 테이블의 일부를 CPU에 저장하는 것이다.
- TLB
  - 변환 색인 버퍼가 캐시에 성공할 경우, TLB 히트, 캐시에 실패할 경우 TLB 미스라고 한다.

`역 페이지 테이블`

- 기존 페이징 방식과 반대로 페이지 테이블을 구성한다.
- 특징
  - 프로세스의 수와 상관없이 테이블이 하나만 존재한다.
  - 물리 메모리 기준으로 프레임 테이블을 만들기 때문에, 전체 테이블 개수가 1개다.
- 장점
  - 테이블의 크기가 작다.
  - 페이지 테이블의 행 수는 실제 프레임의 수와 같다.
- 단점
  - 물리 메모리에 접근할 때 프로세스 아이디와 페이지 번호를 모두 찾아야 한다.

`다단계 페이지 테이블`

- 개요
  - 컴퓨터의 발전으로, 주소 공간이 늘어나, 페이지 테이블의 크기가 늘어나면 한꺼번에 관리하기가 힘들다.
- 특징
  - 일정 크기로 나눈 테이블의 바깥쪽에 이를 관리하는 새로운 테이블을 만드는 것이다.
  - 페이지 테이블의 크기가 커질수록, 3단계나 4단계 등의 새로운 테이블이 지속적으로 생성된다.
