# 01. 프로세스간 통신

### 01. 프로세스 간 통신의 개념

`IPC(Inter Proccess Communication)`

스레드는 하나의 프로세스 내에서 자원을 공유하는 실행 단위다.

스레드는 프로세스 내에 공유된 메모리영역을 갖고 있다.

하지만, 프로세스는 그렇지 않고, 사용하는 메모리 영역이 다르기에, 공유된 메모리를 통신하는 방법은 쉽지 않다.

→ 운영체제는 프로세스끼리 쉽게 통신을 할 수 있게 하는 방법을 제공하는데, 이를 IPC라 한다.

`프로세스 간 통신의 종류`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/38e97f3b-9804-47cc-af06-b63454a06218/Untitled.png)

- 공유 메모리나 공유 파일을 이용한 통신
  - 프로세스 간 통신 중 가장 원시적인 방식
  - 일정한 메모리 영역이나 파일을 공유하고, 이를 통해 데이터를 주고 받는다.
  - 주고 받는 방식을 프로세스끼리 정해야하기에 원시적인 방법이라고 한다.
- 파이프를 이용한 통신
  - 하나의 컴퓨터 내에서 프로세스간 통신에 가장 많이 사용되는 방식
  - 운영체제에서 제공하는 프로세스 간 통신 기법
  - 일반적으로, fork()로 만들어진 부모-자식 간 통신에 이용된다.
- 소켓을 활용한 통신
  - 컴퓨터와 컴퓨터가 네트워크로 연결된 경우의 통신에 주로 사용된다.
  - 소켓은 네트워크로 연결된 컴퓨터에서 데이터를 주고 받기 위해 사용된다.
  - 초기화할 내용도 많고, 시스템 자원을 많이 사용하기 때문에, 다른 컴퓨터일 때 사용함.

→ 같은 컴퓨터 일 때 프로세스 간 통신은 파이프, 네트워크로 연결된 다른 컴퓨터일 때, 소켓을 주로 사용한다.

---

### 2. 프로세스 간 통신의 분류

`통신 방법에 따른 분류`

통신은 데이터가 전송되는 방향에 따라 양방향 통신, 반양방향 통신, 단방향 통신으로 나뉜다.

- 양방향 통신
  - 데이터를 양쪽 방향으로 동시에 전송할 수 있는 구조
  - 일반적인 통신은 모두 양방향 통신
  - 프로세스 간 통신에서는 소켓을 활용한 방식이 양방향 통신이다.
- 반양방향 통신
  - 데이터를 양쪽 방향으로 전송할 수 있지만, 동시에 전송은 불가
  - 특정 시점에 단방향으로 전송 가능
  - 예시로, 무전기가 있다.
- 단방향 통신
  - 한쪽 방향으로만 데이터를 전송할 수 있는 구조
  - 프로세스 간 통신에서는 공유 메모리, 공유 파일을 이용한 통신과 파이프를 이용한 통신이 단방향 통신이다.

파이프나 공유 메모리, 공유 파일같은 단방향 통신을 사용할 때 양방향 통신을 구현하고 싶다면, 공유 메모리나 파이프를 2개를 이용하여 구현 가능하다.

소켓은 양방향 통신이기에 한 개만 이용해도 양방향 통신이 가능하다.

`통신 구현 방식에 따른 분류`

공유 메모리에서 사용하는 통신 방식의 가장 큰 문제점

→ 상대방이 언제 데이터를 보내는지 알 수 없다.

→ 주기적으로, 공유 메모리를 확인하여야 하고, 상태 변화를 확인하기 위해 반복문을 무한 실행하며 기다리는데 이를, 바쁜 대기라고 한다.

→ 이는 시스템 자원에 많은 낭비를 일으킨다.

⇒ 이를 해결하기 위해 **동기화**를 사용한다.

프로세스 간 통신은 동기화 기능에 따라, 대기가 있는 통신(동기화 통신)과 대기가 없는 통신(비동기화 통신)으로 나뉜다.

- 대기가 있는 통신
  - 동기화를 지원하는 통신 방식이다.
  - 데이터를 받는 쪽은 데이터가 도착할 때까지 자동으로 대기 상태에 머무른다.
- 대기가 없는 통신
  - 동기화를 지원하지 않는 방식
  - 바쁜 대기를 활용하여 데이터가 도착했는지 직접 확인한다.

파이프, 소켓 방식이 대기가 있는 통신이기에, 바쁜 대기를 이용하지 않고 활용 가능하다.

### 3. 프로세스 간 통신의 종류

`파일을 이용한 통신`

파일 입출력 코드는 크게 세 부분으로 구성된다.

1. 파일 열기
2. 파일 읽거나 쓰기
3. 파일 닫기

```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd;
    char buf[5];

    fd=open("com.txt", O_RDWR);

    write(fd, "Test", 5);

    read(fd, buf, 5);

    close(fd);

    exit(0);

}
```

1. open으로 com.txt 파일을 연다. O_RDWR은 일고 쓰기 작업을 하겠다는 의미
2. write는 fd변수에 해당하는 텍스트 파일에 Test라는 글자를 쓰겠다는 의미, 5는 5B의 크기를 의미한다.(null체크가 포함되어 1B 추가된다.)
3. read(fd, buf, 5); com.txt파일에 저장된 값을 buf변수에 저장한다는 뜻
4. close를 통해 다 쓴 파일을 닫고, exit(0)을 통해 프로세스 종료한다.

위 과정처럼, 해당 프로세스가 입출력 프로세스와 상호작용을 함을 알 수 있다.

프로세스가 쓰기를 통해 입출력 프로세스에 해당 내용을 전달하고, 읽기를 통해, 입출력 프로세스가 저장 장치로 부터 받아온 내용을 프로세스에 전달하는 일종의 프로세스간 통신이라고 볼 수 있다.

`파이프를 이용한 통신`

파일을 이용한 통신과 다르게, 운영체제가 제공하는 동기화 통신 방식이다.

하지만, 단방향 통신이기 때문에, 양방향 통신을 위해 파이프가 2개 필요하다.

1. 파이프에 쓰기 연산을 하면, 데이터가 전송되고 읽기 연산을 하면 데이터를 받는다.
2. 2번 프로세스가 읽기 연산을 수행 했는데, 1번 프로세스가 쓰기 연산을 수행하지 않았다면, 2번 프로세스는 대기 상태가 되고, 1번 프로세스가 데이터를 쓰면, 자동으로 동기화가 된다.

파이프는 이름 없는 파이프, 이름 있는 파이프로 나뉜다.

- 이름 없는 파이프
  - 일반적인 파이프가 이름 없는 파이프다.
  - 부모와 자식 프로세스, 같은 부모를 가진 자식 프로세스 간 통신에 사용된다.
- 이름 있는 파이프
  - FIFO라 불리는 특수 파일을 이용하여 서로 관련 없는 프로세스 통신에 사용된다.

`소켓을 이용한 통신`

인터넷을 사용하기 위해서는 TCP/IP가 있어야 한다.

이 때, IP는 목적지까지 데이터를 전송하는 것이고, 사용되는 주소가 IP주소다.

→ 이 때, 특정 컴퓨터에 도달 했을 때, 프로세스끼리도 구분이 되어야 하는데, 이를 구분하는 것이 포트 번호다.

→ 네트워크를 사용하는 프로세스는 0번부터 65535 사이의 포트 번호를 부여받는다.

- 데몬
  
  - 서버에서 돌아가는 프로세스를 의미
  - 서버용 데몬은 임의의 포트번호가 아닌 약속된 포트번호로 할당된다.
  
  → ex) 웹 데몬(HTTP)의 포트 번호는 80번 파일 데몬(FTPD)는 21번으로 약속되어 있다.

즉, 서버에서의 소켓의 역할

→ 특정 클라이언트가 80번 포트를 점유하고 있으면, 나머지 클라이언트는 지속적으로 기다려야하기 때문에, 하나의 포트에 여러 클라이언트를 가져오기 위해서, 소켓을 활용한다.

→ 즉, 서버에 데이터를 보낸다는 것은 클라이언트 소켓이 서버 소켓에 데이터를 보내는 것이다.

- 원격 프로시저 호출
  - 네트워킹 상황에서 통신할 때, 소켓이나 원격 프로시저 호출을 활용한다.
  - 프로시저 호출이 컴퓨터에 있는 함수를 호출하는 것이면, 원격 프로시저 호출은 다른 컴퓨터에 있는 함수를 호출하는 것이다.
  - 자바와 같은 객체 지향 언어에서 다른 컴퓨터에 있는 다른 메서드를 가져오는 것이 원격 프로시저 호출이다.

→ 이러한 원격 프로시저 호출을 소켓을 이용하여 구현한다.

다른 컴퓨터와 프로세스 통신을 하기 위해서는 다른 컴퓨터의 위치를 파악하고, 원격지의 시스템 내 여러 프로세스 중 어떤 것과 통신할 지 결정해야한다.

이 때, IP 주소, 포트를 통해 다른 컴퓨터의 프로세스를 파악하고, 소켓을 통해 데이터를 주고 받는다.
