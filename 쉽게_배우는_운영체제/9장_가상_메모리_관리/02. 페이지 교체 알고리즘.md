# 02. 페이지 교체 알고리즘

### 1. 페이지 교체 알고리즘의 개요

페이지 부재가 발생할 때, 스왑 영역으로 내보낼 페이지를 정하는 알고리즘

`페이지 교체 알고리즘의 종류`

- 간단한 알고리즘
  - 무작위 알고리즘
    - 무작위로 대상 페이지를 선정하여 스왑 영역으로 보낸다.
  - FIFO
    - 처음 메모리에 올라온 페이지를 스왑 영역으로 보낸다.
- 이론적 알고리즘
  - 최적 알고리즘
    - 미래의 메모리 접근 패턴을 보고 대상 페이지를 선정하여 스왑 영역으로 보낸다.
- 최적 근접 알고리즘
  - LRU
    - 시간적으로 멀리 떨어진 페이지를 스왑 영역으로 보낸다.
  - LFU
    - 사용 빈도가 적은 페이지를 스왑 영역으로 보낸다.
  - NUR
    - 최근에 사용한 적이 없는 페이지를 스왑 영역으로 보낸다.
  - FIFO 변형
    - FIFO 알고리즘을 변형하여 성능을 높인다.

`페이지 교체 알고리즘의 성능 평가 기준`

- 페이지 부재 횟수
- 페이지 요청 후의 평균 대기시간 비교 등

### 2. 무작위 페이지 교체 알고리즘

- 스왑 영역으로 내보낼 페이지를 무작위로 선정하여 스왑 영역으로 보내버린다.
- 당연히 지역성 등 로직을 전혀 반영하지 않기 때문에, 사용되지 않는다.

### 3. FIFO 페이지 교체 알고리즘

- 먼저 들어온 페이지부터 스왑영역으로 내보낸다.
- 구현 자료 구조
  - 큐로 구성되어 있어, 먼저 들어온 프로세스를 내보냄.
- 가장 오래된 페이지를 스왑 영역으로 내보내기 때문에, 시간 지역성을 만족하지만, 자주 사용하는 프로세스를 내보내게 되면 오히려 비효율적일 수 있다.

### 4. 최적 페이지 교체 알고리즘

- 정의 및 작동 방식
  - 앞으로 잘 사용하지 않을 것으로 예상 되는 페이지를 스왑 영역으로 내보낸다.
  - 메모리가 앞으로 사용하지 않을 페이지를 살펴보고, 페이지 교체 선정 시점부터 가장 멀리 있는 페이지를 대상 페이지로 선정한다.
- 단점
  - 사실상 사용하지 않을 페이지를 예측하는 것은 불가능하여 구현이 안된다.

### 5. LRU 페이지 교체 알고리즘

- 정의
  - LFU(Least Recently Used) → 최근에 사용되지 않은, 즉 페이지 접근 시간을 기준으로 한다.
  - 페이지에 접근한 시간을 기준으로, 페이지에 접근한 시간이 가장 오래된 페이지를 대상 페이지로 선정하는 알고리즘이다.
- 작동 방식
  - 시간을 갱신하여 오래된 페이지를 대상 페이지로 선정
  - 카운터를 통해 잘 안 쓰는 페이지를 대상 페이지로 선정
  - 참조 비트 시프트 방식을 사용하여 횟수를 기록하고 많이 사용 모든 비트가 밀리므로 최근에 사용한 값이 제일 크다. 따라서 제일 작은 값을 뽑으면 가장 오래전에 사용된 페이지가 된다.

⇒ 이러한 방식의 단점은 시간이나 비트를 유지하기 위해 추가적으로 **낭비되는 메모리 공간이 많다**는 것이다.

### 6. LFU 페이지 교체 알고리즘

- 정의
  - LFU(Least Frequently Used) → 가장 빈번하지 않게 사용된, 즉, 페이지의 사용 빈도를 기준으로 한다.
  - 페이지가 몇 번 사용 됐는지를 기준으로, 대상 페이지를 선정한다.
- 단점
  - LRU와 마찬가지로, 시간이나 비트를 유지하기 위헤 추가적으로 낭비되는 메모리 공간이 많다.

### 7. NUR 페이지 교체 알고리즘

- 정의
  
  - NUR(Not Used Recently), 즉, 최근 미사용 페이지 교체 알고리즘이다.

- 배경
  
  - 1000번 접근한 페이지와 20번 접근한 페이지가 있다면, 20번 접근한 페이지를 대상 페이지로 선정해야 한다.
  - 하지만, 95번 접근한 페이지와 91번 접근한 페이지는 사실상 사용성이 비슷하다고 봐도 무방하다.
  
  → 정확한 접근 값을 유지하여 공간을 낭비하는 것보다, 대략적으로 접근한 근사치만 알더라도, 무방하다.

- NUR 관련 용어
  
  - 참조 비트
    - 페이지에 접근하면 1이 된다.
  - 변경 비트
    - 페이지가 변경되면 1이 된다.

- 원리
  
  - 참조 비트와 변경비트를 활용하여 2bit만 추가되는 방식이다.
  - 특정 페이지의 비트 초기값이 (0, 0)으로 읽기 또는 실행이 발생하면 (1, 0), 변경만 일어나면 (0, 1), 둘 다 발생하면 (1, 1)이다.
  - 대상 페이지를 선정하는 우선 순위는 (0, 0), (0, 1), (1, 0), (1, 1) 순이다.
  - 흔하지는 않지만, 모든 페이지가 (1, 1)일 때, 우선 순위 판별이 불가하여, 모든 페이지의 비트를 (0, 0) 으로 초기화 한다.

- 특징
  
  - LRU, LFU 등의 알고리즘과 성능은 비슷하지만, 앞선 알고리즘보다 공간 절약의 이점이 있어 현재 가장 많이 사용하는 알고리즘이다.

### 8. FIFO 변형 알고리즘

- 기존 FIFO와의 차이
  - 기존 FIFO는 메모리에 올라오는 순서만 고려하고, 자주 사용하는 페이지 여부를 고려하지 않아, 성능이 좋지 않다.
  - 이를 개선한 방식으로 2차 기회 알고리즘과 시계 알고리즘이 존재한다.

`2차 기회 페이지 교체 알고리즘`

- 작동 방식
  - 기존 FIFO와 마찬가지로 큐를 사용한다.
  - 특정 페이지에 접근할 때, 페이지 부재가 발생하지 않을 경우, 해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외 한다.
- 성능
  - FIFO보다 좋고, LRU, LFU, NUR 페이지 교체 알고리즘보다 약간 낮다.
- 단점
  - 큐 유지 비용이 높고, 페이지의 잔류가 성공하면, 큐의 맨 뒤로 이동하는 비용이 존재함.

`시계 알고리즘`

- 작동 방식
  - 2차 기회 페이지 알고리즘과 작동 방식은 유사하지만, 구현만 다른 형태다.
  - 참조 비트를 참고하여, 해당 페이지가 메모리에 있다면, 생존하고, 포인터를 계속 내려가면서 대상 페이지를 선정한다.
- 특징
  - NUR 보다 추가 공간이 적게 들지만, 알고리즘이 복잡하고, 계산량이 많은 단점이 있다.
