# 메모리

## 1. 메모리 계층

![Untitled (1)](https://github.com/ganjisriver/Computer-Science/assets/109566855/81e7f86d-8a02-4553-81e8-0f4985eae71d)

- 위 그림에서 기본적으로 올라갈수록 처리 속도가 빠르고, 용량이 작은 것이 특징이다.

- **레지스터**: CPU 내부에 있는 작은 메모리
  
  - Windows 운영체제를 사용할 떄, Windows (x32), (x64)의 버전을 본적이 있을텐데, 일반적으로 레지스터가 저장할 수 있는 용량이라고 생각하면 편하다. (x32는 32bit, x64는 64bit) 물론 x32, x64에 따라 cpu의 아키텍처나 내부 구조 또한 다르다는 점을 알면 좋다.

- **L1, L2 캐시**
  
  - 레지스터는 CPU의 명령, 산술을 처리하는 역할을 한다면, L1, L2 캐시는 레지스터와 메모리의 중간역할을 하는 캐시 메모리다. 일반적으로, CPU는 멀티코어로 이루어져있고, 해당 코어당 하나의 L1 캐시를 갖고 있다. L2 캐시는 이러한 L1 캐시 여러개와 상호작용한다. 이러한 L2 캐시를 여러개 갖고 있는 L3 캐시라는 개념도 있지만, L3 캐시의 경우 고사양 CPU에만 달려 있는 경우가 대부분이다. 인텔의 i7, i5 시리즈는 L3캐시를 CPU에 내장하고 있다. 또는 L3 캐시가 CPU에 달려있지 않고, 메인보드에 달려있는 경우도 흔하다.
  - 단계는 CPU가 필요로 하는 데이터가 L1 캐시가 갖고 있으면, 레지스터에 바로 전달하고, 없으면, L2 캐시에게 요청, L2 캐시가 갖고 있으면, L1 캐시에게 전달, L2 캐시도 없으면 메모리에 요청을 하는 형식으로 이루어진다고 생각하면 좋다.
  - L1, L2 구조 이미지
  
  ![Untitled (2)](https://github.com/ganjisriver/Computer-Science/assets/109566855/cf146106-b640-45d3-9550-62d74aff1160)

- **메모리(RAM)/ 주기억장치**: 우리가 알고 있는 RAM이고, 휘발성과 속도가 보통이다.
  
  - 일반적으로 보조기억장치에 있는 데이터를 저장해놓고 CPU와 상호작용하여 필요한 연산을 하는데에

- **SDD, HDD/ 보조기억장치**
  
  - 우리가 알고 있는 SDD, HDD 컴퓨터에 있는 로컬 디스크, 저장 장치 등이 이에 해당함.

### 캐시

- 정의
  
  - 데이터 처리가 빠른 저장소와 느린 저장소 사이의 간극을 메우기 위한 메모리를 의미함.
  - 캐시 메모리와 보조 기억 장치에 있는 주 기억장치를 캐싱 계층이라고 볼 수 있고, 이렇게 속도의 차이를 채우기 위한 계층을 캐싱 계층이라고 함.

- 이렇게 물리적으로 계층을 분리하는 것말고 직접 계층을 하는 방식을 적용하는 것이 지역성의 원리

- **시간 지역성**
  
  - 최근 사용한 데이터에 다시 접근하려는 특성
  - ex) for문 돌릴 때 i에 계속 접근하려는 것과 같은 이치

- **공간 지역성**
  
  - 최근 접근한 데이터를 이루고 있는 공간이나 그에 가까운 공간에 접근하려는 특성을 의미한다.
  - 배열을 순회할 때, 근처 인덱스에 연속적으로 접근하는 경우가 그렇다.

### 캐시 히트와 캐시 미스

![Untitled (3)](https://github.com/ganjisriver/Computer-Science/assets/109566855/c15af8fd-0b91-40b7-a3f4-0b0075bccea8)

- 캐시히트: 캐시 공간에 제어장치가 원하는 데이터가 있어 메모리에 접근하지 않고 바로 CPU로 가져올 수 있는 경우
- 캐시미스: 캐시 공간에 없어, 데이터를 메모리에 접근해서 가져와야 하는 경우가 캐시 미스다.
- CPU의 연산 장치와의 물리적 거리의 차이에 따라 속도 차이가 나기 때문에, 캐시 여부에 따라 성능이 다르다.

### 캐시 매핑

- 정의: 캐시가 히트 되기 위해 매핑하는 방법을 의미한다.
- CPU의 레지스터와 주 메모리 간 데이터를 주고 받을 때의 방식을 설명함.
- **직접 매핑 (directed mapping)**
  - 메모리가 1~ 100까지 있고 캐시가 1~10까지 있으면 1: 1~10, 2: 11~20 의 형식으로 매핑하는 것을 의미함.
  - 처리가 빠르지만, 충돌이 잦다.
- **연관 매핑 (associative mapping)**
  - 순서와 상관없이 관련 있는 캐시들을 매핑합니다. 충돌이 적지만, 모든 블록을 탐색해야 해서, 속도가 느립니다.
- **집합 연관 매핑 (Set Associative Mapping)**
  - 직접 매핑과 연관 매핑을 합쳐 놓은 방식으로, 순서는 일치시키되, 집합을 둬서 블록화 시킨다.
  - 예를 들어, 캐시 1~10, 메모리 1~ 100이 있다면, 캐시 1~5에 1~50의 데이터를 무작위로 저장시킨다.
    - 일반적으로 집합 연관 매핑을 많이 활용한다.

우리가 백준에서 문제를 풀 때, Python으로 풀 떄 시간 초과 나는 문제가 Pypy로 풀 때, 그 시간 초과가 해결 되는 경우가 있는데, 그것도 캐시와 관련되어있다.

- **Python vs pypy**
  
  ### **컴파일 언어vs 인터프리터 언어의 개념** 비교
  
  - `**컴파일 언어**` : 소스 코드를 기계어로 컴파일(Compile time) -> 실행파일 만듦 -> 실행(Run time)
  - `**인터프리터 언어**` : 코드를 한줄씩 읽어 가며 실행
  - 일반 적으로 python이 C로 구현되어 있다고 알려져 있는데, 그 구현체가 CPython이다. 가장 처음 만들어진 python 구현체이다.
  - CPython은 언터프리터이면서 컴파일러이다. 우리가 작성하는 python코드를 bytecode로 컴파이라고 실행한다.
  - 다시 말해 ,python코드를 C언어로 바꾸는 것이 아니라, **컴파일 하여 bytecode로 바꾸고 그 다음 인터프리터(가장 머신)가 실행**한다.
  - PyPy3에서 사용하는 `JIT(just in time) 컴파일`이란 프로그램을 실행하기 전에 컴파일 하는 대신, 프로그램을 실행하는 시점에서 필요한 부분들을 **즉석으로 컴파일 하는 방식**이고 보통 인터프리터 언어의 성능 향상을 목적으로 도입하는 경우가 많다. 인터프리트 하면서 **자주 쓰이는 코드를 캐싱**하기 때문에 인터 프리터의 느린 실행속도를 개선할 수 있다. JVM에서도 바이트 코드를 기계어로 번역할 때 JIT 컴파일러를 사용한다..
  
  **정리하면,** PyPy3에서는 실행시, **자주 쓰이는 코드를 캐싱하는 기능이 있기 때문에** ,
  
  간단한 코드상에서는 Python3가 메모리, 속도 측에서 우세할 수 있다.
  
  복잡한 코드(반복)을 사용하는 경우에서는 PyPy3가 우세하다.

- **Python의 정수 캐싱(integer caching)**
  
  - 파이썬은 자바처럼 원시 타입이 없고, 모든 값이 객체지만, -5 ~ 256의 값은 할당될 때, 고정된 영역에 있는 메모리 주소를 할당한다.
  
  ```python
  a = 10
  b = 10
  print(a is b)  # True
  
  x = 1000
  y = 1000
  print(x is y)  # False
  
  ## a와 b는 10이라는 값을 할당받았기 때문에, 동일한 객체로 인식한다.
  ## 하지만, x와 y는 -5 ~ 256의 범위에서 벗어난 값이기 때문에, 다른 주소값을 새로 할당 받아 다른 객체로 인식한다.
  ```

### 웹 브라우저의 캐시

- 웹 브라우저에서도 캐시를 사용한다. 이는 사용자 별 커스텀한 정보, 인증 관련 사항을 웹 브라우저에 저장하여, 서버에 요청할 때의 인증, 중복 요청 방지 등을 위해 사용한다.
- **쿠키**
  - 쿠키는 만료 기간이 있는 키-값 저장소로, 4KB까지 저장 가능하며, 만료기한을 정할 수 있음.
  - 백엔드에서 response header에 “set-cookie”라는 이름으로 키-밸류 값을 담아 보내면 프론트에서 따로 로직 처리하지 않아도, 쿠키에 값을 저장하게 할 수 있음.
- **로컬 스토리지**
  - 로컬 스토리지는 만료기한이 없는 키-값 저장소다. 10MB까지 저장 가능하다. 웹 브라우저를 닫아도, 도메인 단위로 저장, 생성이 가능하다. HTML5 이상을 사용하는 브라우저에서만 지원 가능하다.
- **세션 스토리지**
  - 세션 스토리지는 만료기한이 없는 키-값 저장소다. 5MB까지 저장이 가능하고, 탭을 닫을 때 데이터가 삭제된다. 로컬 스토리지와 마찬가지로 HTML5 이상을 지원하는 브라우저에서 쓸 수 있다. 또한, 서버가 아닌 클라이언트에서만 수정이 가능하다.

### 데이터 베이스의 캐싱 계층

![Untitled (4)](https://github.com/ganjisriver/Computer-Science/assets/109566855/712c5aa7-5274-4bf6-ac81-b59240d2be95)

- 우리의 서비스도, In-memory DB인 레디스를 통해 캐시를 하는 모습을 볼 수 있다.

## 2. 메모리 관리

- 컴퓨터 내에 한정된 메모리를 최대한 활용해야 함.

### 가상 메모리

- 메모리 관리 기법 중 하나로, 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리 처럼 보이게 하는 것.

![Untitled (5)](https://github.com/ganjisriver/Computer-Science/assets/109566855/59f1b204-eac4-4d4c-bf67-b7d366baf910)

- 이 때 가상적으로 주어진 주소를 가상 주소라고 하고, 실제 메모리 상에 있는 주소를 실제 주소라고 함.
- 가상 주소는 MMU(메모리 관리 장치)에 의해 실제 주소로 변환이 되기 때문에, 사용자는 가상 주소를 신경 쓰지 않고, 프로그램을 구축할 수 있다.
- **`TLB`**
  - 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 하여 성능 향상 시킨다.

### 스와핑

- 가상 메모리에는 존재하지만, 실제 메모리에는 없을 경우, 페이지 폴트가 발생한다. 이를 방지하기 위해, RAM에서 사용하지 않는 영역을 하드디스크에 내리고, 올리는 과정을 스와핑이라고 한다.

### 페이지 폴트

- 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생.
- 그래서 위에 말한 스와핑을 통해 페이지 폴트가 발생하지 않은 것처럼 프로그램을 작동시켜줌.
1. CPU는 물리 메모리를 확인하여 해당 페이지가 없으면 트랩을 발생시켜 운영체제에 알림
2. 운영체제는 잠시 CPU의 동작을 멈추게 함.
3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하여 물리 메모리에 비어있는 프레임을 찾고, 없다면 스와핑이 발동한다.
4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화 한다.
5. CPU 재가동

### 스레싱

- 스레싱은 메모리의 페이지 폴트율이 높은 것을 의미하고, 당연하게도 컴퓨터의 성능 저하를 초래한다.

![Untitled (6)](https://github.com/ganjisriver/Computer-Science/assets/109566855/d9779bdc-2950-4f87-921d-5c008a7c2f1d)

- 페이지 폴트가 일어나면 CPU 이용률이 낮아지고, CPU 이용률이 낮으면 운영체제가 메모리에 더 많은 프로세스를 올리기에 악순환이 발생한다.
- 이를 해결하기 위해 매모리 늘리기, HDD를 SDD로 바꾸는 등의 방법이 있다. 그 외적으로도, 해결할 수 있는 방식에 작업 세트와 PFF가 있다

`작업 세트`

- 프로세스의 과거 사용 이력인 지역성을 활용하여 미리 메모리에 로드함.
- 이는 스와핑을 줄여 탐색 비용을 줄일 수 있다.

`PFF(Page Fault Frequency)`

- 페이지 폴트의 빈도를 상한선과 하한선을 두어 조절한다.
- 상한선이 되면 페이지를 늘리고, 하한선에 도달하면 페이지를 줄인다.

### 메모리 할당

- 메모리에 프로그램을 할당할 때는 시작 메모리 위치, 메모리의 할당 크기를 기반으로 할당함.

`연속 할당`

- 메모리에 연속적으로 공간을 할당함 이는 다시 고정 분할 방식과 가변 분할 방식으로 나뉨.

![Untitled (7)](https://github.com/ganjisriver/Computer-Science/assets/109566855/fa8a9197-7432-49c9-adbb-8024f59aa7ac)

- 위 그림처럼 프로세스 A, 프로세스 B, 프로세스 C가 순차적으로 공간에 할당하는 것을 볼 수 있다.
- `고정 분할 방식`
  - 메모리를 미리 나누어 관리하는 방식
  - 단점은 메모리를 미리 나눈 공간에 비해 프로그램이 필요한 메모리가 더 작아 공간이 남는 현상을 말하는 내부 단편화가 발생한다.
- `가변 분할 방식`
  - 프로그램의 크기에 맞게 메모리를 나누어 사용한다.
  - 이 종류로는 최초적합, 최적적합, 최악적합 등이 있다.

`불연속 할당`

- 페이징
  - 동일한 크기의 페이지로 나누어 서로 다른 위치에 프로세스 할당
- 세그멘테이션
  - 크기가 동일하지 않고, 코드나 데이터 함수 등의 범위에 따라 할당
- 페이지드 세그멘테이션
  - 물리적 메모리는 페이지, 공유나 보안 등은 세그멘테이션으로 나누는 방식

### Java는 stack과 heap 메모리를 어떻게 사용할까?

`stack 메모리`: 함수의 지역 변수와 매개 변수 + 함수가 호출될 때마다 스택 프레임이 쌓임

`heap 메모리`: 객체 저장 → 런타임 환경에 있는 인스턴스 객체 등

1번 예시

```java
public class Main {
    public static void main(String[] args) {
        int a = 7;
        a = wow(a);
    }
    public static int wow(int num) {
        int b = num*4;
        return b;
    }
****}
```

2번 예시

```java
public class Main {
    public static void main(String[] args) {
        Counter c = new Counter();
        two(c);
        int count = c.get();
    }
    public static void two(Counter c) {
        c.increment();
        c.increment();
    }
}

public class Counter {
    private int state = 0;
    public void increment() {
        state++;
    }
    public int get() {
        return state;
    }
}
```

### 참고자료

- **L1, L2 캐시 관련 참고 자료**
  
  [[엔지니어링] CPU와 캐시 (L1/L2/L3 캐시..)](https://12bme.tistory.com/402)
  
  [CPU의 캐시 메모리는 어떤 역할을 하는가?](https://it.donga.com/215/)
  
  [캐시메모리 L1/L2/L3 ??? 이게 뭔데?](https://sonb3579.tistory.com/15)

- **Python vs pypy**
  
  [Python3 와 PyPy3 차이](https://ralp0217.tistory.com/entry/Python3-%EC%99%80-PyPy3-%EC%B0%A8%EC%9D%B4)

- **스택 힙 메모리 예제 설명 영상**
  
  [변수와 객체와 메모리의 관계! 자바를 예로 들어 변수와 객체는 메모리에 어떻게 저장되는지 정말 쉽게 설명해요!](https://youtu.be/GIsr_r8XztQ)

- **페이징 테이블과 TLB**
  
  [[운영체제OS] 페이지 테이블이란? Page Table 원리와 역할](https://jhnyang.tistory.com/443)
