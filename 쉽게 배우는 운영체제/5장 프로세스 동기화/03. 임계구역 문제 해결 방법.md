# 03. 임계구역 문제 해결 방법

### 임계 구역 문제 해결 조건 고려

1. 프로세스 P1과 P2는 임계구역에 진입하기 전에 코드를 통해 임계구역에 잠금이 걸려있는 지 확인한다.(lock=true)
2. 임계 구역이 잠겨있다면, 무한루프를 돌며 기다린다.
3. 임계 구역을 점유한 프로세스가 lock을 풀면 무한 루프를 빠져나와 작업한다.
4. 임계 구역에 새로 들어가는 프로세스도 마찬가지 과정을 가진다.

`상호 배제 문제`

1. P1이 무한루프를 돌다가 lock이 풀려 임계구역에 진입한다.
2. 하지만, 타임아웃이 발생하여 문맥교환이 일어나 P2가 실행한다.
3. P1이 lock을 잠그지 않아 P2가 임계구역에 진입한다.
4. P2가 임계구역에 진입하고, P1이 다시 실행상태로 들어가면, 이미 임계구역에 진입된 상태다.
5. 결국 P1, P2 모두 lock을 걸고 임계구역에 진입한 상태로, 설계대로 되지 않는다.

→ 이는 상호 배제 조건을 보장하지 않아 문제가 발생한다.

`한정 대기 문제`

위에서 언급한 상호 배제 문제를 해결하기 위해서 공유 변수인 lock을 lock1, lock2로 나누었다.

이렇게 될 경우, 서로 다른 프로세스 간의 lock을 확인하기 때문에, 상호 배제 조건을 보장한다.

→ 하지만, 이렇게 서로의 프로세스 별로 lock을 걸 경우, 한정 대기 문제가 발생할 수 있다.

1. P1이 lock1=true를 실행 후, 타임 아웃이 발생하고, 문맥 교환이 발생하여 P2가 실행된다.
2. P2도, lock2=true를 실행하고, 타임 아웃이 발생한다.
3. 이 경우, 서로의 lock이 true인 상태로 타임아웃이 발생하여 서로의 프로세스가 무한 루프를 벗어나지 못하는 상황이 발생한다.

→ 이러한 상황을 교착 상태(dead lock)이라고 한다. 프로세스는 살아 있으나, 작업이 진행되지 못하는 상태를 의미한다.

이러한 코드의 경우, 확장성 문제도 발생하는데, 프로세스의 개수가 늘어나면, lock의 개수도 늘어나 비효율적이다.

`진행의 융통성 문제`

이를 해결하기 위해, lock을 다시 한개로 두고, lock을 boolean형이 아니라 프로세스의 번호를 부여하여 해당 프로세스가 lock을 걸었음을 표시하는 방식이 있다.

ex) lock== 1, lock==2 등

해당 코드의 경우, 임계 구역에 대한 접근을 P1, P2 번갈아 해야하기 때문에, P1이 연속으로 임계구역에 접근해야할 때, 문제가 발생한다.

→ 이렇듯, P2가 P1의 진행을 방해하는 등의 현상을 **경직된 동기화**라고 한다.

`하드웨어로 해결 방법`

하드웨어를 통해, while문과 lock의 잠금을 동시에 실행하게 되면, 타임아웃으로 발생한 임계구역을 보호하지 못하는 문제가 해결된다.

→ 하지만, 하드웨어를 통한 방법은 바쁜 대기를 사용하여 검사하기 때문에, 자원 낭비가 발생한다.

아래서 언급하는 알고리즘은 이러한 문제를 해결하기 위한 알고리즘이지만, 현재는 구조가 복잡하여 현재 잘 사용되지는 않는다.

---

### 3. 피터슨 알고리즘

피터슨 알고리즘은 lock1, lock2 등 lock을 프로세스별로 거는 방식은 유사하지만, turn이라는 변수를 추가로 사용하여 위 문제를 해결한다.

lock1이 잠구고, turn에 2를 할당함으로써, 다른 프로세스에 양보한다.

while문에 lock과 turn 변수를 동시에 조건문을 검으로써, 교착 상태를 방지한다.

→ 하지만, 프로세스가 2개일 때만 유효하고, 3개 이상일 경우, 코드를 지속적으로 변경해야 되는 문제가 발생한다.

### 4. 데커 알고리즘

데커 알고리즘의 방식을 P1 입장에서 살펴본다.

1. 프로세스 P1은 우선 잠금을 건다.
2. 프로세스 P2의 잠금이 걸렸는지 확인한다.(while(lock2 == true))
3. 만약 프로세스 P2도 잠금을 걸었다면, 누가 먼저 인지 확인한다.
4. 프로세스 P1은 잠금을 풀고 P2가 작업을 마칠 때 까지 기다린다.

→ 임계구역 문제 해결의 세 가지 조건을 모두 만족하지만, 알고리즘이 복잡해진다.

### 5. 세마포어

해당 알고리즘은 프로세스가 임계구역에 진입하기 전에 스위치를 사용 중으로 놓고 임계구역으로 들어간다.

이후에 도착하는 프로세스는 앞의 프로세스가 작업을 마칠 때까지 기다린다.

해당 알고리즘에서는 임계구역이 잠겼는지 직접 점검하거나, 바쁜 대기를 하거나, 다른 프로세스에 동기화 메시지를 보낼 필요가 없다.

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled 10.png](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2010.png)

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled 11.png](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2011.png)

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled 12.png](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2012.png)

- Semaphore(.) : 전역변수 RS를 n으로 초기화. n은 현재 사용 가능한 자원의 수
- P() : 잠금을 수행하는 코드
  - RS>0이면 (사용 가능한 자원이 있으면) : RS를 1만큼 감소시키고 임계구역 진입
  - RS≤0이면 : 0보다 커질 때 까지 block()
- V() : 잠금 해제와 동기화를 같이 수행
  - RS 값을 1 증가시킴
  - 세마포어에서 기다리는 다른 프로세스에게 wake_up() 신호를 보내 임계구역에 진입해도 좋다는 신호 보냄
- 뮤텍스랑 같음
- 간편하게 구현 가능
- 현재 알고리즘도 잘 사용하지는 않음.

### 6. 모니터

세마포어 알고리즘은 피터슨이나 데커보다 단순하고 사용하기 편리하지만, 문제가 없지 않다.

→ 잘못된 사용으로 임계구역이 보호받지 못한다는 점이다.

`작동원리`

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled 16.png](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2016.png)

- 임계구역으로 들어가려는 프로세스는 직접 `P()` 혹은 `V()`를 사용하지 않음
- 대신 모니터에게 작업을 **요청**
- 모니터는 요청받은 작업을 모니터 큐에 저장하고 순서대로 처리, 결과만 프로세스에 알려줌

### 모니터

- 모니터는 데이터와 프로시저 (메소드, 함수)를 포함하는 객체
  
  - 모니터 안에서만 접근 가능

- 모니터 경계에서는 상호 배제를 엄격히 지켜야 함
  
  - 한번에 한 스레드만 모니터 진입 가능
  - 모니터는 상호 배제 보장

- 모니터가 사용되고 있을 때 들어가려는 스레드는 대기해야 함

- 모니터 안의 데이터는 모니터 내의 프로시저를 통해서만 접근 가능

- 상호배제, 동기화 두가지 모두 구현
  
  - **동기화**
    
    - 예를 들어 생산자와 소비자의 예에서 소비자가 아직 미처 소비하지도 않았는데 계속해서 데이터를 공급하는 경우
    - 한정된 큐에서 계속해서 공급하면 오버플로우 발생
    - 그러므로 생산자는 소비자가 버퍼를 비웠을 때 공급하고, 소비자는 생산자가 버퍼를 채웠을 때 소비해야 하며 이를 동기적으로 실행하는 것이 동기화.
  
  - 동기화를 구현하기 위해 **조건 변수** 구현
    
    - **조건 변수**
      
      `wait(.) signal(.)` Copy
      
      어떤 조건 변수에 대해서 동작을 수행할 때 까지 대기하고 있다가 해당 동작이 완료되면 기다리고 있는 프로세스에게 시그널을 보내면 깨어나 모니터를 얻음

### 모니터 코드

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled 17.png](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2017.png)

- 제공하는 인터페이스만 간단히 사용하면 끝

![https://yansigit.github.io/posts/공유자원과-임계구역/Untitled 18.png](https://yansigit.github.io/posts/%ea%b3%b5%ec%9c%a0%ec%9e%90%ec%9b%90%ea%b3%bc-%ec%9e%84%ea%b3%84%ea%b5%ac%ec%97%ad/Untitled%2018.png)

### 자바 모니터

- 멀티 스레드를 사용하는 자바 응용 프로그램에서 상호 배제와 동기화를 제공
- `Synchronized` 키워드
  - 자바 객체에 상호 배제 기능 부여
- `Wait()` 메소드
  - 객체에 대한 잠금을 해제하고 상태 변수를 기다림
- 스레드는 `notify()` 혹은 `notifyAll()` 메소드를 호출해 신호 보냄
