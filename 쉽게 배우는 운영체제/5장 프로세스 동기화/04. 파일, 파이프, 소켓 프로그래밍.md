# 04. 파일, 파이프, 소켓 프로그래밍

### 1. 파일

`순차 파일`

파일은 아무리 큰 파일이라도, 파일 내의 데이터는 개념적으로 한 줄로 처리 된다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a15f85f2-e4ef-410b-ab4b-49e861380e54/Untitled.png)

```
Test
wax
end
형태로 출력된다고 했을 때,
실제적으로는 Test \\n wax \\n end\\0 과 같이 한줄로 길게 저장된다.
```

파일 내의 데이터가 한 줄로 길게 저장되는데, 이러한 파일을 **순차 파일**이라 한다.

`파일 기술자`

1. 파일에 대한 접근 권한, 파일을 여는 방식 등 이를 만족하면 파일 기술자 fd를 얻는다.
2. 파일 기술자는 현재 파일에서 어느 위치를 읽고 있는지를 가리킨다.
3. 파일 기술자는 파일 당 하나이고, 읽기와 쓰기가 파일 기술자를 공유한다.
4. 최초 파일이 열릴 때, 파일 기술자는 맨 앞에 위치하고, 파일을 읽거나 쓰면, 다음 개행 문자 등으로 전진한다.

`파일을 이용한 통신`

일반적으로 부모 프로세스와 자식 프로세스가 파일을 이용하여 통신을 한다.

해당 과정에서 부모 프로세스와 자식 프로세스 간의 동기화가 필요하다.

1. 자식 프로세스 생성을 위해 fork()를 시행하기 전에 open()을 하게 되면, 생성된 파일 기술자가 자식 프로세스에도 상속된다.
2. 이러한 과정 때문에, open() 함수 호출은 한 번이지만, close() 함수는 자식, 부모 프로세스 각각 발생해줘야 한다.
3. 자식 프로세스가 파일을 읽고 종료를 하게 되면, 파일 기술자의 위치가 전진된 상태로 종료되기 때문에, lseek() 함수 호출을 통해, 파일 기술자의 위치를 다시 0으로 이동시킨다.

파일 이용한 통신은 운영체제가 두 프로세스 간 동기화를 지원해 주지 않기 때문에, 부모 프로세스가 wait() 함수를 통해 자식 프로세스의 작업이 끝날 때 까지 기다렸다가 작업을 시작한다.

---

### 2. 파이프

- 정의와 사용처
  - 단방향 통신 시스템인 파이프는 이름 없는 파이프와 이름 있는 파이프로 나뉜다.
  - 일반적으로 파이프는 이름 없는 파이프를 가리키고, 파이프는 부모와 자식 프로세스, 같은 부모의 자식 프로세스처럼 관련 있는 프로세스 간 통신에 사용된다.

파이프는 공유 파일 시스템과 달리, 기술자가 따로 존재하여 동기화가 가능하다.

`파일 기술자`

- 파이프는 기술자를 fd[2]와 같이 2개의 원소를 가진 배열로 정의한다.
- 하나는 일기, 하나는 쓰기용으로 정의한다.
- 부모 자식 간 프로세스에서 fork()를 하기 때문에, 파일 기술자의 개수는 총 4개로 볼 수 있다.
- 파이프에서는 프로세스 당 하나의 기술자만 사용하기 때문에, 필요 없는 기술자는 닫는다.

공유 파일 시스템과 달리 파이프는 대기가 존재하기 때문에, wait()이 필요가 없고, 자식 프로세스가 실행될 때 까지 부모 프로세스는 대기 상태로 들어가게 된다.

### 3. 네트워킹

여러 컴퓨터의 프로세스에 데이터를 전달하는 방법 중 가장 대중화된 것은 소켓을 이용한 네트워킹이다.

다른 통신 시스템과 마찬가지로, oepn(), read()/write(), close() 구조를 사용한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/83ea10e9-fbf8-4d25-9375-db65a0b33be5/Untitled.png)

`클라이언트 입장에서의 소켓 통신`

1. connect를 통해 서버에 접속을 시도한다.
2. 서버에 접속 후, read() 혹은 write() 작업을 하고, 작업에 사용된 소켓 기술자를 닫고 종료한다.

`서버 입장에서의 소켓 통신`

1. 서버는 소켓을 생성한 후, bind()를 사용하여, 생성한 소켓을 특정 포인트에 등록한다.
2. 하나의 프로세스라도, 여러 소켓을 생성해야 하기 때문에, bind()를 통해 특정 포트에 새로운 소켓을 등록하겠다는 의미가 된다.
3. bind()를 통해 소켓이 정상적으로 등록이 되면, listen()을 통해 클라이언트를 받을 준비를 한다.
4. accept()를 통해 소켓 기술자가 생성되고 작업이 시작된다.
5. read() 혹은 write()의 작업 등을 한 후, 작업이 마치면, close()를 통해 소켓 기술자를 닫고, 새로운 클라이언트를 기다린다.
