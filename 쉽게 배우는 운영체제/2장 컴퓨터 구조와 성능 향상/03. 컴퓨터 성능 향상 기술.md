# 03. 컴퓨터 성능 향상 기술



컴퓨터 내 부품 사이에서도 속도의 차이가 발생한다. CPU, 메모리, 주변장치의 작업속도가 다르다. 메인보드 내 메모리와 주변장치는 시스템 버스로 이어져있고, CPU의 레지스터, 제어 장치, 산술연산장치는 CPU 내부 버스로 이어져 있다. 이 장치들간의 속도 괴리를 해결하기 위한 많은 기술들이 있다.

1. **버퍼**
- 보관 창고 5개의 귤을 도마로 옮길 때, 한 개씩 옮기는 것보다 바구니에 담아 한꺼번에 옮기는 것이 효율적이다. → 바구니가 버퍼의 역할을 한다고 생각하면 된다.
- 개념
  - 입출력장치에서 데이터를 읽을 때마다 하나씩 전송이 아닌 한꺼번에 전송하게 되면, 적은 작업량으로 높은 효율을 가지게 된다. 이렇게 적은 작업량으로 데이터를 옮겨 효율을 높이는 장치가 버퍼다.
- 하드디스크의 사양의 표기 예시 중 1TB, 7200rpm, 256MB로 표기하는데, 1TB가 용량, 7200rpm이 회전 속도, 256MB가 버퍼의 용량이다. → 같은 속도면 버퍼가 큰 것이 더 빠르다.
- 소프트웨어에서 버퍼
  - 동영상 스트리밍
    - 동영상을 볼때와 플레이어의 시간 속도 차이로 버퍼링이 발생할 수 있다.
    - 플레이어가 재생하는 도중 데이터가 도착하지 않으면, 버퍼링이 발생하게 되는데, 이러한 현상을 방지하기 위해 데이터의 일정 부분을 버퍼에 넣고 실행한다
- 모니터 버퍼
  - printf(”Hello \n”)이라는 출력문을 실행할 때, 한 줄이 다 차지 않으면 출력을 하지 않는 경우가 있다. \n은 일반적으로 줄 바꿈을 의미하는데, 버퍼에 저장된 내용을 출력하라는 의미도 갖는다.

---

`스풀`

- CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적 버퍼
- 프린터 스풀러
  - 인쇄할 내용을 순차적으로 출력하는 소프트웨어로 출력 명령을 내린 프로그램과 **독립적**으로 작동한다.
  - 스풀러를 사용하지 않을 때, 출력 명령을 내린, 워드프로세서와 같은 프로그램을 사용하지 못할 수 있지만, 스풀러를 사용하면, 독립적으로 인쇄를 실행하기에, 인쇄 중에 작업을 할 수 있다.
- **버퍼와 스풀러의 차이**
  - 버퍼의 경우, 프로그램이 버퍼를 공유하기 때문에, 어떤 프로그램의 데이터든 버퍼가 다 차면 이동이 시작된다.
  - 스풀러의 경우, 한 인쇄물이 끼어들 수 없기에 프로그램 간에 배타적이다.

---

`캐시`

- 개념
  - CPU와 메모리 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장해 두는 임시 장소
  - 필요한 데이터를 미리 가져와 한 번에 전달하는 버퍼의 일종이라고 볼 수 있다.
  - 이렇듯, CPU가 미리 사용할 것 같은 데이터를 미리 가져다 놓는 작업을 **미리 가져오기**라고 한다.
- CPU 내부 캐시는 CPU 내부 버스를 이용하기 때문에, 시스템 버스를 사용하는 메모리보다 속도가 높다. 이 차이를 통해 캐시는 CPU와 메모리 사이의 속도 차이를 완화시킨다.
- **캐시히트와 캐시미스**
  - CPU가 원하는 데이터가 CPU 내부 캐시에 있으면 캐시히트, 없으면 캐시미스라고 한다.
  - 일반적인 CPU 캐시 적중률은 90%정도 된다.
- 캐시 적중률을 높이는 방법
  1. 캐시의 크기 늘리기
     - 당연히 캐시에 저장되는 데이터가 많으면 캐시히트가 될 확률이 올라간다.
  2. 데이터 가져오기
     - 위치 상 가까운 데이터를 사용할 확률이 높다는 지역성의 원리를 통해 가져온다.
     - 10행의 코드가 실행이 되었다면, 100행보다는 11행에 있는 코드가 다음에 실행될 확률이 높은 것과 같은 원리다.
- 캐시와 메모리 사이의 데이터 불일치
  - 캐시의 데이터와 메모리의 데이터 간의 불일치로 메모리에 있는 데이터를 변경하는 방식에는 두가지가 있다.
  - **즉시 쓰기**
    - 캐시에 있는 데이터가 변경되면 즉시 메모리에 반영한다.
    - 메모리로의 데이터 교환이 빈번하여, 성능이 저하되지만, 급작스러운 정전 등에 의한 데이터 유실의 가능성이 낮다.
  - **지연 쓰기**
    - 캐시에 있는 데이터가 변경될 때, 그 내용을 주기적으로 반영하는 방식, **카피백**이라고도 함
    - 시스템 성능은 올라가지만, 메모리와 캐시된 데이터 사이의 불일치가 발생할 가능성이 높아진다.
- 캐시의 구분
  - 프로그램의 명령어는 명령어 부분과 데이터 부분으로 나눈다.
  - 일반 캐시
    - 명령어와 데이터의 구분 없이 모든 자료를 가져온다.
    - 메모리와 연결되어 모든 자료를 가져오기 때문에, L2캐시라고 부른다.
  - 특수 캐시
    - 명령어와 데이터를 구분하여 가져온다.
    - 특수 캐시는 명령어 캐시와 데이터 캐시로 구분된다.
    - 이는 CPU 레지스터에 직접 연결되어 L1캐시라고 부른다.
  - CPU 레지스터 → L1 캐시 → L2 캐시 → 메모리의 계층형으로 연결되어 있다고 생각하면 좋다.

---

1. **저장장치의 계층 구조**

레지스터(CPU) → 캐시 → 메모리 → 저장 장치

- 비용의 한계 때문에, 저장 장치 간 계층 구조가 발생한다.
- 이러한 게층 구조는 계층 간의 **데이터 일관성 문제**가 발생한다.
  - 이러한 문제는 캐시에 저장된 데이터가 메모리에 반영되지 않고, 컴퓨터가 꺼질 경우, 반영이 안된다.
  - 버퍼를 사용하는 하드디스크에서, 하드웨어를 갑자기 제거할 경우 또한 일관성이 무너져 문제가 발생한다.

---

1. **인터럽트**
- 개념
  - CPU의 작업과 저장 장치의 데이터 이동을 독립적으로 운영함으로써, 시스템 효율을 높이는 방식이다.
  - 데이터 입출력이 이루어지는 동안 CPU가 다른 작업을 할 수 있다.

`인터럽트 방식의 동작 과정`

1. CPU가 입출력 관리자에게 입출력 명령을 보낸다.
2. 입출력 관리자는 명령 받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 CPU에 완료 신호를 보낸다.

→ 입출력 관리자가 CPU에 보내는 완료 신호를 인터럽트라고 한다.

- CPU는 입출력 관리자에게 작업 지시를 내리고, 다른 일을 하다가, 완료 신호를 받으면 옮겨진 데이터를 처리한다. → 이처럼 하던 일을 중단하고, 처리해야 하는 신호라는 의미로 인터럽트라고 한다.
- 다양한 주변 장치 중 어떤 입출력 장치의 작업이 끝났는 지를 확인하기 위해 인터럽트 번호라는 것을 사용한다.
- 여러 입출력 장치들이 동시에 작업을 할 수 있으며, 일일이 작업을 끝날 때마다, 인터럽트가 발생하면 비효율적이기 때문에, 인터럽트 벡터를 사용함.

`인터럽트 벡터`

- CPU가 인터럽트 번호가 적힌 인터럽트 벡터를 받으면, 작업이 끝난 인터럽트 번호에 해당하는 작업을 한번에 처리한다.

전원 버튼을 눌러 강제 종료 하거나, 자신에게 주어진 메모리 영역을 초과하여 작업할 때, 0으로 숫자를 나눌 때 등도 인터럽트가 발생하게 된다.

---

1. **직접 메모리 접근**
- 과거
  - 과거의 운영체제는 폴링 방식을 채택했기 때문에, CPU가 메모리, 주변 장치에 대한 모든 권한을 갖고 있었다.
  - 효율성을 높이기 위해 인터럽트 방식을 활용하면서, 입출력 관리자가 데이터 입출력을 맡게 되었다.
- 메모리 접근 권한
  - 명령을 받은 입출력 관리자는 CPU가 요청한 데이터를 메모리에 가져다 놓아야한다.
  - 기본적으로 메모리는 CPU만 접근 권한을 갖고 있기 때문에, 입출력 관리자는 메모리에 접근이 불가능하다.
  - 이를 실현하기 위해 입출력 관리자가 CPU허락 없이 메모리에 접근할 수 있는 권한이 생겼고, 이를 직접 메모리 접근이라고 한다.

---

1. **메모리 맵 입출력**
- 입출력 관리자가 CPU의 관여 없이 메모리에 데이터를 저장하게 되면, 메모리의 복잡성이 발생한다.

→ 입출력 관리자와 CPU가 사용하는 메모리 영역을 구분하여 사용하는 방법이 고안되었다. 이를 메모리 맵 입출력이라고 한다.

---

1. **사이클 훔치기**
- CPU와 입출력 장치가 메모리에 동시 접근할 경우가 생긴다.
- 이 경우 CPU가 속도가 빠르기 때문에, 입출력 관리자에게 양보한다.
- 직접 메모리 접근이 CPU의 사이클을 훔쳐간 것이 되기 때문에, 사이클 훔치기라고 한다.
