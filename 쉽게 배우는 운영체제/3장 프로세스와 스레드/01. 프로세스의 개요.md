# 01. 프로세스의 개요

1. **프로세스의 개념**
- 프로그램은 하드디스크같은 저장 장치에 보관되어 있다가 마우스로 더블클릭하면 실행된다.
- 프로그램 실행
  - 폰노이만 구조에서 프로그램이 실행 된다는 것은 하드 디스크에 있던 프로그램이 메모리에 올라와 작업이 진행된다는 것이다.
  - 프로그램은 저장장치에 저장된 정적인 상태이고, **프로세스**는 실행을 위해 메모리에 올라온 동적인 상태이다.

---

1. **프로그램에서 프로세스로의 전환**

다음은 시분할 방식 시스템에서 프로그램이 프로세스로 전환되는 방식을 소개한다.

1. 운영체제는 프로그램을 메모리의 적당한 위치로 가져온다.
2. 동시에, 프로세스를 처리하는 다양한 정보가 들어 있는 작업 지시서의 역할을 하는 **프로세스 제어 블록**(PCB, Proccess Control Block)을 만든다.

`프로세스 제어 블록`

프로세스 제어 블록에 담긴 대표 3가지는 다음과 같다.

- `프로세스 구분자`
  - 메모리에는 여러개의 프로세스가 존재하기 때문에, 프로세스를 구분하기 위한 프로세스 구분자가 존재한다.
- `메모리 관련 정보`
  - CPU는 프로세스가 메모리의 어느 부분에 존재하는지 알기 위해, 프로세스 위치를 알아야 한다.
  - 따라서, 프로세스 제어 블록에는 프로세스의 메모리 위치 정보가 담겨 있다.
  - 또한, 메모리 보호를 위한 경계 레지스터와 한계 레지스터도 포함되어 있다.
- `각종 중간값`
  - 프로세스 제어 블록에는 프로세스가 사용했던 중간값이 저장된다.
  - 이는 여러 프로세스가 번갈아 가며 실행되기 때문에, 각 프로세스는 일정 시간 작업을 한 후 다른 프로세스에 CPU를 넘겨 준다.
  - EX) 프로세스 A가 103행까지 작업하고 다른 프로세스로 CPU를 넘겨주었을 때, 다음 프로세스A가 작업할 부분은 104행부터다. PCB에는 다음에 작업해야할 코드의 위치가 담긴 프로그램 카운터가 저장된다.
  - 또한, 작업의 중간값을 보관 중인 다른 레지스터도 같이 저장된다.
  - 즉, 각종 중간값은 여러 프로세스가 번갈아 실행이 될 때, 각각의 프로세스가 자신들이 다시 어디에서 실행해야 하는지의 지표가 된다고 볼 수 있다.

PCB는 운영체제가 프로세스를 실행하기 위해 관리하는 데이터 구조이기 때문에, 운영체제 영역에 만들어 진다. 프로세스가 종료되면 프로세스는 메모리에서 삭제되고, 프로세스 제어 블록도 폐기된다.

---

1. **프로세스의 상태**

`일괄 작업 시스템에서의 프로세스 상태`

- 프로세스가 생성된 후, CPU를 획득 하고, 작업을 마치면 종료 된다.
- 일괄 작업 시스템의 프로세스 상태는 생성, 실행, 완료 중 하나다.

`시분할 시스템에서의 프로세스 상태`

- 시분할 시스템에서의 프로세스 상태는 일괄 작업 시스템보다 복잡하다. 프로세스가 CPU를 번갈아 가면서 획득하기 때문이다.

`프로세스의 네 가지 상태`

![Untitled](./assets/3-1-1%20프로세스의%20네%20가지%20상태.png)

- 생성 상태
  - 프로세스가 메모리에 올라와 실행 준비를 완료한 상태다.
  - 프로세스를 관리하는데 필요한 PCB가 생성된다.
- 준비 상태
  - 생성된 프로세스가 CPU를 얻을 때까지 기다리는 상태다.
  - CPU가 한 개인 컴퓨터에서는 한 번에 하나의 프로세스만 실행할 수 있기 때문에, 자기 순서가 될 때까지 준비 상태에서 기다려야 한다.
- 실행 상태
  - 준비 상태에 있는 프로세스 중 하나가 CPU를 얻어 실제 작업을 수행하는 상태(excecute status)
  - 실행 상태에 들어간 프로세스는 일정 시간동안 CPU를 획득한다.
  - 주어진 시간 내에 프로세스가 완료되지 못했다면, 준비 상태로 돌아와 다음 차례를 기다린다.
- 완료 상태
  - 실행 상태의 프로세스가 주어진 시간 동안 작업을 마치면 완료 상태로 진입한다.
  - 완료 상태가 되면 PCB가 사라진 상태를 의미 한다.

`CPU 스케줄러`

- 준비 상태에 존재하는 프로세스 중 다음에 실행할 프로세스를 선정하는 일은 CPU 스케줄러가 담당한다.
- CPU 스케줄러는 프로세스의 전 상태, 생성, 준비, 실행, 완료에 관여하여 모든 프로세스의 작업이 원만하게 이루어지도록 만든다.
- `디스패치`
  - 준비 상태의 맨 앞에 기다리고 있는 프로세스를 실행 상태로 바꾸는 작업
- `타임 슬라이스 or 타임 퀀텀`
  - 실행 상태에 들어간 프로세스에 배당된 작업 시간
- `타임아웃`
  - 주어진 타임 슬라이스 동안 작업을 처리하지 못하여 준비 상태로 다시 돌아가는 것
- 새로운 프로세스가 실행 상태로 들어오면 CPU는 타임 슬라이스만큼 시간이 흐르면 알려달라고 클록에 요청한다.
- 클록이 시간이 되었다고 CPU 스케줄러에게 전달하면, 타임아웃되게 된다. 이를 클록으로부터의 인터럽트라고 부른다.

---

`프로세스의 다섯 가지 상태`

![Untitled](./assets/3-1-2%20프로세스의%20다섯%20가지%20상태.png)

- 현대에서는 효율성 측면을 위하여 프로세스의 상태를 다섯 가지로 늘렸다.

- 이전에 다뤘던 입출력을 요구하는 프로세스를 다루기 위해서 **대기 상태**라는 것이 추가되었다.

- `입출력 프로세스와 대기상태`
  
  - 입출력을 요구하는 프로세스는 입출력이 발생할 때 까지 기다려야 하는데, 해당 프로세스를 실행 상태에 둘 경우, 타임아웃 될 때까지 기다려야 하는 비효율이 발생하기 때문에, 대기 상태라는 곳에 입출력이 될 때까지 기다린다.
  - 대기 상태의 프로세스는 요청한 입출력이 완료되면 입출력 관리자로부터 인터럽트를 받는다.
  - 인터럽트를 받은 프로세스는 실행 상태로 돌아가지 않고, 준비 상태로 돌아 간다.

- 생성 상태
  
  - 프로그램이 메모리에 올라오고 운영체제로부터 PCB를 할당받은 상태이다.

- 준비 상태
  
  - 실행 대기 중인 모든 프로세스가 자신의 순서를 기다리는 상태다.
  - PCB는 ready queue에서 기다리며 CPU 스케줄러에 의해 관리 된다.
  - 실제로는 다수의 ready queue가 있는 상태이며, 몇 개의 ready queue를 운영할 지, 어떤 프로세스의 PCB를 실행 상태로 보낼지 결정한다.

- 실행 상태
  
  - 프로세스가 CPU를 할당 받아 실행되는 상태
  - 준비 상태에서 실행 상태로 들어가는 프로세스의 개수는 CPU의 개수다.
  - 실행 상태에 들어간 프로세스는 타임 슬라이스만큼 작업할 수 있다.
  - 시간을 다 사용할 경우, 다시 준비 상태로, 프로세스가 완료 되면, 완료 상태로 간다.
  - 실행 상태에 있는 프로세스가 입출력을 요청을 할 경우, 대기 상태로 옮긴다.

- 대기 상태
  
  - 실행 상태에 있는 프로세스가 입출력을 요청했을 때, 입출력이 완료될 때까지 기다리는 상태
  - 입출력 장치마다 마련된 큐에 PCB가 담겨 대기하게 된다. 입출력이 완료되어, 입출력 관리자가 인터럽트를 발생시키면, 해당 프로세스는 준비상태로 돌아간다.

- 완료 상태
  
  - 프로세스가 종료되는 상태
  - 사용했던 데이터, 코드를 메모리에서 삭제하고 프로세스 제어 블록을 폐기한다.
  - 오류나 비정상적인 프로세스에 의해 종료될 경우
    - 직전의 메모리 상태를 저장장치로 옮기는 데 이를 **코어 덤프**라고 한다.

---

`휴식 상태와 보류 상태`

위의 프로세스 5가지 상태를 활성 상태라고 한다. 활성 상태 외적인 상태로, 프로세스의 휴식 상태와 보류 상태가 있다.

- 휴식 상태
  - 프로세스가 작업을 일시적으로 쉬고 있는 상태
  - 유닉스에서 프로그램을 실행하는 도중 Ctrl + Z 를 누르면 볼 수 있다.
  - 사용하던 데이터가 메모리에 그대로 있고, 프로세스 제어 블록(PCB)도 그대로 유지된다.
  - 해당 프로세스는 멈춘 상태에서 다시 재시작 할 수 있다.
- 보류 상태
  - 보류 상태는 프로세스가 메모리에서 잠시 쫒겨난 상태라는 점에서 휴식 상태와 차이가 있다.
  - 보류 상태는 ‘일시 정지 상태’라고도 불린다.
  - 다음은 프로세스가 보류 상태가 되는 조건이다.
    - 메모리가 꽉 차 프로세스를 메모리 밖으로 내보낼 때
    - 프로그램에 오류가 있어 실행을 미룰 때
    - 바이러스와 같이 악의적인 공격을 하는 프로세스라고 판단될 때
    - 매우 긴 주기로 반복되는 프로세스라 메모리 밖에 놔도 큰 문제가 없을 때
    - 입출력을 기다리는 프로세스의 입출력이 계속 지연될 때
  - 이 외에도 다양한 이유로 보류 상태로 프로세스가 들어가는데, 대개 컴퓨터의 성능을 떨어뜨리거나, 실행을 미루어도 큰 지장이 없는 프로세스가 해당한다.

`보류 상태를 포함한 프로세스의 상태`

![Untitled](./assets/3-1-3%20보류%20포함한%20프로세스의%20상태.png)

- 보류 상태에 들어간 프로세스는 메모리 밖으로 쫓겨나 스왑 영역에 보관 된다.
- 스왑 영역
  - 메모리에서 쫒겨난 데이터가 임시로 보관되는 곳이다.
  - 하드디스크의 일부를 스왑 영역으로 할당하여 사용한다.
- 보류 상태와 휴식 상태의 차이
  - 보류 상태는 프로세스가 메모리에서 쫒겨나 스왑 영역에 있는 상태
  - 휴식 상태는 프로세스가 메모리에 남아 있으나 멈춘 상태를 의미한다.
- 보류 상태
  - 보류 대기 상태(block suspend)
    - 대기 상태에서 보류 상태로 옮겨진 상태
    - 입출력이 완료 되면 보류 준비 상태로 들어간다.
  - 보류 준비 상태(ready suspend)
    - 준비 상태에서 보류 상태로 옮겨진 상태
  - 두 가지 상태 모두 재시작하면, 원래의 활성 상태로 옮겨 간다.
