# 03. 프로세스의 연산

1. **프로세스의 구조**

프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성되어 있다.

워드프로세서의 예시

- 코드 영역: 프로그램 자체

- 데이터 영역: 편집 중인 문서

- 스택 영역: 운영체제가 워드프로세스를 관리하기 위한 부가 데이터

- `코드 영역`
  
  - 프로그램의 본문이 기술된 영역, 텍스트 영역이라고도 함
  - 이 코드 영역은 읽기 전용으로 처리된다.

- `데이터 영역`
  
  - 코드가 실행되면서 사용하는 변수, 파일 등의 데이터
  - 읽기와 쓰기가 모두 가능하며, 상수로 선언된 변수는 읽기 전용이다.

- `스택 영역`
  
  - 운영체제가 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳이다.

---

1. **프로세스의 생성과 복사**

프로세스는 프로그램을 실행할 때 생성된다. 생성 단계에서 운영체제는 프로그램을 메모리 영역으로 가져와 코드 영역에 넣고, PCB를 생성한 후, 메모리에 데이터 영역과 스택 영역을 확보한 후 프로세스를 실행 한다.

`fork() 시스템 호출의 개념`

- fork() 시스템 호출
  - 실행 중인 프로세스로부터 새로운 프로세스를 복사하는 함수를 커널에서 제공함
  - fork() 시스템 호출을 하면 실행 중인 프로세스와 똑같은 프로세스가 하나 더 만들어진다.
- 예를 들어, 이미 실행중인 워드 프로세서를 하나 더 실행할 때, fork() 시스템 호출을 통해 기존 워드 프로세서를 복사하여 실행하는 것이 더 빠르다.

`fork() 시스템 호출의 동작 과정`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/35f7d878-b961-44a6-8d53-67224c4df41a/Untitled.png)

- fork() 시스템 호출을 하면 프로세스 제어 블록을 포함한 부모 프로세스 영역의 대부분이 자식 프로세스에 복사되어 똑같은 프로세스가 만들어진다.
- 단, PCB의 내용 중 일부가 변경되는데 그 내용은 다음과 같다.
  - 프로세스 구분자(PID)가 바뀐다.
  - 부모 프로세스와 자식 프로세스가 차지하는 메모리 영역이 달라야 하기 때문에, 메모리 관련 정보가 바뀐다.
  - 부모 프로세스 구분자(PPID)와 자식 프로세스 구분자(CPID)가 바뀐다.

---

`fork() 시스템 호출의 장점`

- 프로세스 생성 속도가 빠르다.
  - 하드디스크로부터 프로그램을 가져오는 것이 아닌 기존 메모리에서 복사하기 때문에, 생성 속도가 빠르다.
- 추가 작업 없이 자원 상속 가능
  - 부모 프로세서가 사용하던 모든 자원을 추가 자원 없이 자식 프로세스에 상속이 가능하다.
- 시스템 관리를 효율적으로 할 수 있다.
  - 부모 프로세스와 자식 프로세스가 구분자로 연결되어 있기 때문에, 자식 프로세스를 종료하면, 부모 프로세스가 정리할 수 있다.

---

1. **프로세스의 전환**

`exec() 시스템 호출의 개념`

- 기존 프로세스를 새로운 프로세스로 전환하는 함수다.
- 목적
  - 프로세스의 구조를 재활용하기 위해 사용된다.
  - 새로운 프로세스를 만들려면 PCB를 만들고, 메모리 자리를 확보하는 과정이 필요하다.
  - 프로세스 종료 후 사용한 메모리 청소하기 위해 상위 프로세스와 부모-자식 관계를 만들어야 하지만, exec()함수를 통해 PCB, 메모리 영역, 부모-자식 관계를 그대로 사용할 수 있어 편하다.

`exec() 시스템 호출의 동작 과정`

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5b636ec6-dc83-4b59-b88d-1c28d7d05418/Untitled.png)

- 코드 영역
  - 기존 내용이 지워지고 새로운 코드로 바뀐다.
- 데이터 영역
  - 새로운 변수로 채워진다.
- 프로세스 제어 블록
  - 프로세스 구분자, 부모 프로세스 구분자, 자식 프로세스 구분자, 메모리 관련 사항은 변하지 않는다.
  - 프로그램 카운터 레지스터 값, 각종 레지스터 및 파일 정보가 리셋된다.

---

1. **프로세스의 계층 구조**

`유닉스 프로세스 계층 구조`

- 유닉스에서 커널이 처음 메모리에 올라와 부팅 되면, 커널 관련 프로세스를 여러 개 만든다.
- init 프로세스를 만든 다음 나머지 프로세스를 init 프로세스의 자식으로 만든다. 운영체제에 있는 모든 프로세스는 init 프로세스의 자식이 되어 트리 구조를 만든다.

`프로세스 계층 구조의 장점`

프로세스의 계층 구조는 동시에 여러 작업을 처리 하고 종료된 프로세스의 자원을 회수하는 데 유용하다.

- 여러 작업의 동시 처리
  - 예를 들어, login 프로세스를 실행할 때, 사용자 3명이 동시에 컴퓨터에 접속한다면, 한 프로세스는 한 명의 유저만 처리할 수 있다.
  - 이 때, fork()를 통해 login 프로세스를 여러 개 만들어 나누어 주어 동시에 사용자를 login처리한다.
  - login을 처리한 후 shell 프로세스가 필요하다. shell 프로세스가 있어야 사용자가 운영체제에 명령을 내리고, 결과를 받을 수 있다.
  - login 프로세스가 완료된 후 exec() 시스템 호출을 이용해 login 프로세스가 차지하고 있던 메모리 자원을 활용해 효율적으로 프로세스를 관리할 수 있다.
- 용이한 자원 회수
  - 프로세스를 계층 구조로 만들면 프로세스 간의 책임 관계가 분명해져 시스템 관리가 용이해진다.
  - 모든 프로세스가 독립적이면 프로세스 종료 시 운영체제가 직접 자원을 회수해야 하기 때문에, 작업이 복잡해지는데, 부모-자식간의 관계로 만들면, 자식 프로세스가 작업을 마칠 때, 부모 프로세스가 해당 책임을 가져 회수하면 된다.

`고아 프로세스와 좀비 프로세스`

- 부모 프로세스는 자원을 회수하기 위해 자식 프로세스가 끝날 때 까지 기다려야 한다.
- 부모 프로세스가 먼저 종료되거나, 자식 프로세스가 비정상적으로 종료되어 연락이 안될 경우, 자원이 그대로 남는 문제가 발생 하게 된다.
- 고아 프로세스
  - 자식 프로세스보다 부모 프로세스가 먼저 종료될 경우를 의미
- 좀비 프로세스
  - 자식 프로세스가 종료되었는데, 부모 프로세스가 뒤처리를 하지 않은 경우

→ 고아 프로세스와 좀비 프로세스를 운영체제는 주기적으로 확인하여 자원을 회수해야 한다.
